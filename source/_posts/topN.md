title: Top N 问题
date: 2015-07-20 19:47:05
tags:  Algorithm
---

转载自 <http://www.cnblogs.com/zhjp11/archive/2010/02/26/1674227.html>
原文格式不太好，调整下格式

今天看算法分析是，看到一个这样的问题，就是在一堆数据中查找到第k个大的值。

名称是：

        设计一组N个数，确定其中第k个最大值

这是一个选择问题，当然，解决这个问题的方法很多，本人在网上搜索了一番，查找到以下的方式，决定很好，推荐给大家。
所谓“第（前）k大数问题”指的是在长度为n(n>=k)的乱序数组中S找出从大到小顺序的第（前）k个数的问题。

- **解法1**： 我们可以对这个乱序数组按照从大到小先行排序，然后取出前k大，总的时间复杂度为O(n\*logn + k)。
- **解法2**： 利用选择排序或交互排序，K次选择后即可得到第k大的数。总的时间复杂度为O(n\*k)
- **解法3**： 利用快速排序的思想，从数组S中随机找出一个元素X，把数组分为两部分Sa和Sb。Sa中的元素大于等于X，Sb中元素小于X。这时有两种情况：
 1.  Sa中元素的个数小于k，则Sb中的第k-|Sa|个元素即为第k大数；
 2.  Sa中元素的个数大于等于k，则返回Sa中的第k大数。**时间复杂度近似为O(n)**
- **解法4**： 二分[Smin,Smax]查找结果X，统计X在数组中出现，且整个数组中比X大的数目为k-1的数即为第k大数。
    时间复杂度平均情况为O(n\*logn)
- **解法5**：用O(4\*n)的方法对原数组建最大堆，然后pop出k次即可。时间复杂度为O(4\*n + k\*logn)
- **解法6**：维护一个k大小的最小堆，对于数组中的每一个元素判断与堆顶的大小，若堆顶较大，则不管，
    否则，弹出堆顶，将当前值插入到堆中。时间复杂度O(n \* logk)
- **解法7**：利用hash保存数组中元素Si出现的次数，利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大数，**平均情况下时间复杂度O(n)**

附注：
1.  STL中可以用nth_element求得类似的第n大的数（由谓词决定），使用的是`解法3`中的思想，还可以用partial_sort对区间进行部分排序，得到类似前k大的数（由谓词决定），它采用的是`解法5`的思想。
2.  求中位数实际上是第k大数的特例。编程之美》2.5节课后习题：
 + 如果需要找出N个数中最大的K个不同的浮点数呢？比如，含有10个浮点数的数组（1.5，1.5，2.5，3.5，3.5，5，0，- 1.5，3.5）中最大的3个不同的浮点数是（5，3.5，2.5）。
``` 
 解答：上面的解法均适用，需要注意的是浮点数比较时和整数不同，另外求hashkey的方法也会略有不同。
```
 +  如果是找第k到第m(0&lt;k&lt;=m&lt;=n)大的数呢？
```
解答：如果把问题看做m-k+1个第k大问题，则前面解法均适用。
但是对于类似前k大这样的问题，最好使用解法5或者解法7，总体复杂度较低。
```
 +  在搜索引擎中，网络上的每个网页都有“权威性”权重，如page rank。如果我们需要寻找权重最大的K个网页，而网页的权重会不断地更新，那么算法要如何变动以达到快速更新（incremental update）并及时返回权重最大的K个网页？
 ```
 提示：堆排序？当每一个网页权重更新的时候，更新堆。还有更好的方法吗？
 解答：要达到快速的更新，我们可以解法5，使用映射二分堆，可以使更新的操作达到O(logn)
 ```
 + 在实际应用中，还有一个“精确度”的问题。我们可能并不需要返回严格意义上的最大的K个元素，在边界位置允许出现一些误差。当用户输入一个query的时候，对于每一个文档d来说，它跟这个query之间都有一个相关性衡量权重f (query, d)。搜索引擎需要返回给用户的就是相关性权重最大的K个网页。如果每页10个网页，用户不会关心第1000页开外搜索结果的“精确度”，稍有误差是可以接受的。比如我们可以返回相关性第10 001大的网页，而不是第9999大的。在这种情况下，算法该如何改进才能更快更有效率呢？网页的数目可能大到一台机器无法容纳得下，这时怎么办呢？
 ```
提示：
归并排序？如果每台机器都返回最相关的K个文档，
那么所有机器上最相关K个文档的并集肯定包含全集中最相关的K个文档。
由于边界情况并不需要非常精确，如果每台机器返回最好的K'个文档，那么K'应该如何取值，
以达到我们返回最相关的90%*K个文档是完全精确的，
或者最终返回的最相关的K个文档精确度超过90%（最相关的K个文档中90%以上在全集中相关性的确排在前K），
或者最终返回的最相关的K个文档最差的相关性排序没有超出110%*K。

解答：
正如提示中所说，可以让每台机器返回最相关的K'个文档，
然后利用归并排序的思想，得到所有文档中最相关的K个。 
最好的情况是这K个文档在所有机器中平均分布，这时每台机器只要K' = K / n （n为所有机器总数）；
最坏情况，所有最相关的K个文档只出现在其中的某一台机器上，这时K'需近似等于K了。
我觉得比较好的做法可以在每台机器上维护一个堆，然后对堆顶元素实行归并排序。
 ```
 + 如第4点所说，对于每个文档d，相对于不同的关键字q1, q2, …, qm，分别有相关性权重f（d, q1），f（d, q2）, …, f（d, qm）。如果用户输入关键字qi之后，我们已经获得了最相关的K个文档，而已知关键字qj跟关键字qi相似，文档跟这两个关键字的权重大小比较靠近，那么关键字qi的最相关的K个文档，对寻找qj最相关的K个文档有没有帮助呢？
 ```
 解答：肯定是有帮助的。
 在搜索关键字qj最相关的K个文档时，
 可以在qj的“近义词”相关文档中搜索部分，然后在全局的所有文档中在搜索部分。
 ```